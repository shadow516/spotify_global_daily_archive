<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Global Top 10 Insights</title>
    <style>
        /* Basic styles - assuming Poppins font */
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 2rem;
            background-color: #121212;
            color: #e0e0e0;
            line-height: 1.6;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #181818;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }
        h1, h2 {
            color: #1DB954; /* Spotify Green */
            border-bottom: 1px solid #282828;
            padding-bottom: 0.5rem;
            margin-top: 1.5rem;
        }
        h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
        }
        h2 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
        }
        p, li {
            font-size: 1rem;
            color: #b3b3b3;
        }
        strong {
            color: #e0e0e0;
            font-weight: 600;
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        li {
            background-color: #282828;
            margin-bottom: 0.75rem;
            padding: 1rem;
            border-radius: 5px;
            border-left: 3px solid #1DB954;
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Space between items like icon and text */
        }
        .highlight {
            color: #1DB954;
            font-weight: bold;
        }
        .negative-highlight {
            color: #ff4d4f; /* Red for negative changes */
            font-weight: bold;
        }
        .date-header {
            text-align: center;
            font-size: 1.2rem;
            color: #b3b3b3;
            margin-bottom: 2rem;
        }
        .back-button {
            display: inline-block;
            margin-bottom: 2rem;
            padding: 10px 20px;
            background-color: #1DB954;
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: #1AA34A;
        }
        .movement-icon {
            font-size: 1.2em; /* Adjust size as needed */
            vertical-align: middle;
        }
        .movement-icon.up { color: #1DB954; } /* Green for up */
        .movement-icon.down { color: #ff4d4f; } /* Red for down */
        .movement-icon.neutral { color: #b3b3b3; } /* Grey for no change */

        /* Loading spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #1DB954;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-button">← Back to Main Dashboard</a>

        <h1>Spotify Global Top 10 Insights</h1>
        <p id="fecha-actualizacion" class="date-header"><span class="spinner"></span> Loading data...</p>

        <div id="resumen-novedades">
            </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const resumenContainer = document.getElementById('resumen-novedades');
        const fechaHeader = document.getElementById('fecha-actualizacion');

        // Regex for detecting collaborators like (feat. Artist)
        const featRegex = /\s*\((?:ft|feat|featuring|with|w[\/\\]?)\s*([^)]+)\)/i;

        // --- Helper Functions ---
        function parseSongArtistForDisplay(songArtistString) {
            if (!songArtistString) return { artist: 'Unknown', song: 'Unknown', collaborators: [] };

            let song = songArtistString;
            let artist = 'Unknown';
            let collaborators = [];

            const parts = songArtistString.split(' - ');
            if (parts.length > 1) {
                artist = parts.shift().trim(); // This is the main artist
                song = parts.join(' - ').trim(); // The rest is the song title, potentially with collaborators

                // Extract collaborators from the song title using regex
                const match = song.match(featRegex);
                if (match && match[1]) {
                    collaborators = match[1].split(/,\s*|\s*&\s*|\s+and\s+/i).map(c => c.trim());
                    song = song.replace(featRegex, '').trim(); // Remove collaborator part from song title
                }
            } else {
                song = songArtistString.trim();
            }

            return { artist, song, collaborators };
        }

        function formatNumber(num) {
            if (typeof num === 'string' && num.includes(',')) num = num.replace(/,/g, ''); // Remove commas if string
            const number = parseInt(num, 10);
            return isNaN(number) ? '-' : number.toLocaleString('en-US'); // Use en-US for commas
        }

        function getPositionChangeText(currentPos, prevPos) {
            let icon = '';
            let text = '';
            let className = '';

            if (prevPos === null || prevPos === undefined) {
                icon = '✨'; // Star or new entry icon
                text = "(New Entry)";
                className = 'highlight';
            } else {
                const change = prevPos - currentPos;
                if (change > 0) {
                    icon = '⬆️'; // Up arrow
                    text = `(Up <span class='highlight'>${change}</span> ${change === 1 ? 'position' : 'positions'})`;
                    className = 'up';
                } else if (change < 0) {
                    icon = '⬇️'; // Down arrow
                    text = `(Down <span class='negative-highlight'>${Math.abs(change)}</span> ${Math.abs(change) === 1 ? 'position' : 'positions'})`;
                    className = 'down';
                } else {
                    icon = '➡️'; // Right arrow for no change
                    text = "(Maintains position)";
                    className = 'neutral';
                }
            }
            return `<span class="movement-icon ${className}">${icon}</span> ${text}`;
        }

        // Function to calculate points based on position
        function calculatePoints(position) {
            const pointsMap = {
                1: 12, 2: 10, 3: 8, 4: 7, 5: 6,
                6: 5, 7: 4, 8: 3, 9: 2, 10: 1
            };
            return pointsMap[position] || 0;
        }

        // Helper to calculate release date
        function calculateReleaseDate(chartDateStr, daysSinceReleaseStr) {
            const chartDate = new Date(chartDateStr);
            const daysSinceRelease = parseInt(String(daysSinceReleaseStr).replace(/,/g, ''), 10);

            if (isNaN(daysSinceRelease)) {
                return null; // Cannot calculate if days are not a number
            }

            const releaseDate = new Date(chartDate);
            releaseDate.setDate(chartDate.getDate() - daysSinceRelease);
            return releaseDate;
        }

        fetch('spotify_historial.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Sort dates from latest to oldest
                const dates = Object.keys(data).sort((a, b) => new Date(b) - new Date(a));
                
                if (dates.length === 0) {
                    resumenContainer.innerHTML = "<p>No data available in the history.</p>";
                    fechaHeader.textContent = "No data";
                    return;
                }

                const latestDate = dates[0];
                const previousDate = dates.length > 1 ? dates[1] : null;

                const latestTop10 = data[latestDate]?.top_10 || [];
                const previousTop10Data = previousDate ? (data[previousDate]?.top_10 || []) : [];

                // Map previous top 10 for easy lookup
                const previousSongsMap = new Map();
                previousTop10Data.forEach(song => {
                    const key = (song["Song / Artist"] || song["Canción / Artista"] || "").toLowerCase();
                    if (key) {
                        previousSongsMap.set(key, song);
                    }
                });
                
                // Format the date for display
                const displayDate = new Date(latestDate).toLocaleDateString('en-US', {
                    year: 'numeric', month: 'long', day: 'numeric'
                });
                fechaHeader.innerHTML = `Analysis for ${displayDate}`; // Remove spinner

                let htmlOutput = "";

                // 1. Daily Overview
                htmlOutput += `<h2>Daily Overview</h2>`;
                if (latestTop10.length > 0) {
                    const { song: songN1, artist: artistN1 } = parseSongArtistForDisplay(latestTop10[0]["Song / Artist"] || latestTop10[0]["Canción / Artista"]);
                    htmlOutput += `<p>Today, <strong>${songN1}</strong> by <strong>${artistN1}</strong> leads the Global Top 10.</p>`;
                } else {
                    htmlOutput += `<p>No Top 10 data available for today.</p>`;
                }

                // 2. New Entries and Movements
                const newEntries = [];
                const movements = []; // For climbs, drops, maintains

                latestTop10.forEach(currentSong => {
                    const songArtistFullString = currentSong["Song / Artist"] || currentSong["Canción / Artista"];
                    const songKey = songArtistFullString.toLowerCase();
                    const { artist: parsedArtist, song: parsedSong, collaborators: parsedCollaborators } = parseSongArtistForDisplay(songArtistFullString);
                    
                    const currentPos = parseInt(currentSong.Posición || currentSong.Position, 10);
                    const currentStreams = formatNumber(currentSong.Streams);
                    const currentPoints = calculatePoints(currentPos);

                    const prevSongData = previousSongsMap.get(songKey);
                    const prevPos = prevSongData ? parseInt(prevSongData.Posición || prevSongData.Position, 10) : null;
                    const prevPoints = prevSongData ? calculatePoints(prevPos) : null;
                    
                    const changeText = getPositionChangeText(currentPos, prevPos);

                    let listItem = `<li>${changeText} <strong>#${currentPos} ${parsedSong}</strong> by ${parsedArtist}`;

                    if (parsedCollaborators.length > 0) {
                        listItem += ` (feat. ${parsedCollaborators.join(', ')})`;
                    }
                    listItem += `. Streams: ${currentStreams}.`;

                    if (currentSong["Stream Diff"]) {
                        const diff = parseInt(String(currentSong["Stream Diff"]).replace(/,/g, ''), 10);
                        if (!isNaN(diff)) {
                             listItem += ` Stream difference: <span class="${diff >= 0 ? 'highlight' : 'negative-highlight'}">${formatNumber(diff)}</span>.`;
                        }
                    }

                    // Add points info
                    listItem += ` Points: <strong>${currentPoints}</strong>`;
                    if (prevPoints !== null) {
                        const pointDiff = currentPoints - prevPoints;
                        if (pointDiff > 0) {
                            listItem += ` (<span class='highlight'>+${pointDiff}</span>)`;
                        } else if (pointDiff < 0) {
                            listItem += ` (<span class='negative-highlight'>${pointDiff}</span>)`;
                        }
                    }
                    listItem += `.</li>`;


                    if (prevPos === null) {
                        // Check history for last seen
                        let lastSeenDate = null;
                        let isFirstTimeEver = true;
                        // Iterate through ALL dates from the start to find first appearance
                        // This ensures "first time ever" is accurate across the full history
                        const allDatesSortedAsc = Object.keys(data).sort((a, b) => new Date(a) - new Date(b));
                        
                        for (const historyDate of allDatesSortedAsc) {
                            if (historyDate === latestDate) continue; // Skip the current date

                            const historyTop10 = data[historyDate]?.top_10 || [];
                            const foundInHistory = historyTop10.some(s => (s["Song / Artist"] || s["Canción / Artista"]).toLowerCase() === songKey);
                            
                            if (foundInHistory) {
                                lastSeenDate = new Date(historyDate).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                                isFirstTimeEver = false;
                                break; // Found it, no need to check earlier
                            }
                        }

                        let newEntryDetail = "";
                        if (isFirstTimeEver) {
                            newEntryDetail = " (This is its first appearance ever in the Top 10 record!)";
                        } else if (lastSeenDate) {
                            newEntryDetail = ` (Last seen on ${lastSeenDate})`;
                        }
                        
                        // Add new entry specific detail
                        newEntries.push(listItem.replace("(New Entry)", `(New Entry)${newEntryDetail}`));

                    } else {
                        movements.push({pos: currentPos, item: listItem});
                    }
                });
                
                // Sort 'movements' by current position to display them in order
                movements.sort((a,b) => a.pos - b.pos);


                if (newEntries.length > 0) {
                    htmlOutput += `<h2>New Entries in the Top 10</h2><ul>${newEntries.join('')}</ul>`;
                } else {
                    htmlOutput += `<h2>New Entries in the Top 10</h2><p>No new entries in the Top 10 today.</p>`;
                }

                htmlOutput += `<h2>Current Positions & Movements</h2>`;
                if (movements.length > 0) {
                    htmlOutput += `<ul>${movements.map(m => m.item).join('')}</ul>`;
                } else if (newEntries.length === 0) {
                    htmlOutput += `<p>The Top 10 remains identical to the previous day or insufficient data for comparison.</p>`;
                } else {
                    htmlOutput += `<p>All songs not listed as new entries have left the Top 10.</p>`;
                }


                // 3. Daily Highlights & Key Data
                htmlOutput += `<h2>Daily Highlights</h2>`;
                let dailyHighlightsList = "<ul>";
                let noDailyHighlights = true;

                // Song with most streams
                if (latestTop10.length > 0) {
                    let maxStreams = -1;
                    let songMaxStreams = null;
                    latestTop10.forEach(s => {
                        const streams = parseInt(String(s.Streams).replace(/,/g, ''), 10);
                        if (!isNaN(streams) && streams > maxStreams) {
                            maxStreams = streams;
                            songMaxStreams = s;
                        }
                    });
                    if (songMaxStreams) {
                        const parsed = parseSongArtistForDisplay(songMaxStreams["Song / Artist"] || songMaxStreams["Canción / Artista"]);
                        dailyHighlightsList += `<li><strong>Stream Leader:</strong> '${parsed.song}' by ${parsed.artist} is the song with the most streams today, accumulating <strong>${formatNumber(maxStreams)}</strong> plays.</li>`;
                        noDailyHighlights = false;
                    }
                }
                
                // Song with largest stream increase (Stream Diff)
                if (latestTop10.length > 0 && previousDate) {
                    let maxStreamDiff = -Infinity;
                    let songMaxStreamDiff = null;
                    latestTop10.forEach(s => {
                        if (s["Stream Diff"]) {
                            const diff = parseInt(String(s["Stream Diff"]).replace(/,/g, ''), 10);
                            if (!isNaN(diff) && diff > maxStreamDiff) {
                                maxStreamDiff = diff;
                                songMaxStreamDiff = s;
                            }
                        }
                    });

                    if (songMaxStreamDiff && maxStreamDiff > 0) {
                        const parsed = parseSongArtistForDisplay(songMaxStreamDiff["Song / Artist"] || songMaxStreamDiff["Canción / Artista"]);
                        dailyHighlightsList += `<li><strong>Biggest Stream Growth:</strong> '${parsed.song}' by ${parsed.artist} saw the largest increase in streams from the previous day, with <strong>+${formatNumber(maxStreamDiff)}</strong> streams.</li>`;
                        noDailyHighlights = false;
                    }
                }

                // Biggest Climber
                let biggestClimber = null;
                let maxPositionGain = 0; 
                latestTop10.forEach(currentSong => {
                    const songKey = (currentSong["Song / Artist"] || currentSong["Canción / Artista"] || "").toLowerCase();
                    const currentPos = parseInt(currentSong.Posición || currentSong.Position, 10);
                    const prevSongData = previousSongsMap.get(songKey);
                    const prevPos = prevSongData ? parseInt(prevSongData.Posición || prevSongData.Position, 10) : null;

                    if (prevPos !== null) { 
                        const positionGain = prevPos - currentPos;
                        if (positionGain > maxPositionGain) {
                            maxPositionGain = positionGain;
                            biggestClimber = currentSong;
                        }
                    }
                });

                if (biggestClimber && maxPositionGain > 0) {
                    const parsed = parseSongArtistForDisplay(biggestClimber["Song / Artist"] || biggestClimber["Canción / Artista"]);
                    dailyHighlightsList += `<li><strong>Top Climber:</strong> '${parsed.song}' by ${parsed.artist} made the biggest climb today, rising <span class='highlight'>${maxPositionGain}</span> positions to reach <strong>#${parseInt(biggestClimber.Posición || biggestClimber.Position, 10)}</strong>.</li>`;
                    noDailyHighlights = false;
                }

                // Biggest Dropper
                let biggestDropper = null;
                let maxPositionDrop = 0; 
                latestTop10.forEach(currentSong => {
                    const songKey = (currentSong["Song / Artist"] || currentSong["Canción / Artista"] || "").toLowerCase();
                    const currentPos = parseInt(currentSong.Posición || currentSong.Position, 10);
                    const prevSongData = previousSongsMap.get(songKey);
                    const prevPos = prevSongData ? parseInt(prevSongData.Posición || prevSongData.Position, 10) : null;

                    if (prevPos !== null) {
                        const positionDrop = currentPos - prevPos; 
                        if (positionDrop > maxPositionDrop) {
                            maxPositionDrop = positionDrop;
                            biggestDropper = currentSong;
                        }
                    }
                });

                if (biggestDropper && maxPositionDrop > 0) { 
                    const parsed = parseSongArtistForDisplay(biggestDropper["Song / Artist"] || biggestDropper["Canción / Artista"]);
                    dailyHighlightsList += `<li><strong>Top Dropper:</strong> '${parsed.song}' by ${parsed.artist} experienced the biggest drop, falling <span class='negative-highlight'>${maxPositionDrop}</span> positions to <strong>#${parseInt(biggestDropper.Posición || biggestDropper.Position, 10)}</strong>.</li>`;
                    noDailyHighlights = false;
                }


                // If #1 maintained and was in previous day
                if (latestTop10.length > 0 && previousTop10Data.length > 0) {
                    const currentN1Key = (latestTop10[0]["Song / Artist"] || latestTop10[0]["Canción / Artista"] || "").toLowerCase();
                    const prevN1Key = (previousTop10Data[0]["Song / Artist"] || previousTop10Data[0]["Canción / Artista"] || "").toLowerCase();
                    if (currentN1Key === prevN1Key && parseInt(latestTop10[0].Posición || latestTop10[0].Position, 10) === 1) {
                           const parsed = parseSongArtistForDisplay(latestTop10[0]["Song / Artist"] || latestTop10[0]["Canción / Artista"]);
                           dailyHighlightsList += `<li><strong>Holding the Top Spot:</strong> '${parsed.song}' by ${parsed.artist} remains strong at <strong>#1</strong>.</li>`;
                           noDailyHighlights = false;
                    }
                }


                if (noDailyHighlights) {
                    dailyHighlightsList += "<li>No specific daily highlights to feature today or insufficient data for some calculations.</li>";
                }
                dailyHighlightsList += "</ul>";
                htmlOutput += dailyHighlightsList;

                // 4. All-Time Records & Historical Insights
                htmlOutput += `<h2>All-Time Records & Historical Insights</h2>`;
                let historicalHighlightsList = "<ul>";
                let noHistoricalHighlights = true;

                // --- Historical Aggregation ---
                let allTimeNumberOneCounts = new Map(); // songKey -> {count: num_days_at_1, songArtist: "..."}
                let allTimeMostTop10Appearances = new Map(); // songKey -> {count: num_days_in_top10, songArtist: "..."}
                let allTimeArtistPoints = new Map(); // artistName -> total_points
                let allTimeSongPoints = new Map(); // songKey -> total_points

                // New maps for release date based aggregates
                let releaseMonthPoints = new Map(); // "YYYY-MM" (release date) -> total_points
                let releaseYearPoints = new Map();  // "YYYY" (release date) -> total_points
                
                // Track already processed song release dates to avoid recalculating
                const songReleaseDates = new Map(); // songKey -> Date object of its release

                for (const dateString of dates) {
                    const dailyTop10 = data[dateString]?.top_10 || [];
                    const chartDate = new Date(dateString);

                    if (dailyTop10.length > 0) {
                        const topSong = dailyTop10[0];
                        const topSongKey = (topSong["Song / Artist"] || topSong["Canción / Artista"] || "").toLowerCase();
                        if (topSongKey) {
                            allTimeNumberOneCounts.set(topSongKey, {
                                count: (allTimeNumberOneCounts.get(topSongKey)?.count || 0) + 1,
                                songArtist: topSong["Song / Artist"] || topSong["Canción / Artista"]
                            });
                        }

                        dailyTop10.forEach(song => {
                            const songArtistFullString = song["Song / Artist"] || song["Canción / Artista"];
                            const songKey = songArtistFullString.toLowerCase();
                            const { artist: mainArtist, collaborators: songCollaborators } = parseSongArtistForDisplay(songArtistFullString);
                            const position = parseInt(song.Posición || song.Position, 10);
                            const daysSinceRelease = song["Días desde lanzamiento"] || song["Days since release"]; // Get this value

                            if (!isNaN(position)) {
                                const points = calculatePoints(position);

                                // Aggregate points for main artist
                                allTimeArtistPoints.set(mainArtist, (allTimeArtistPoints.get(mainArtist) || 0) + points);

                                // Aggregate points for collaborators (50% each)
                                if (songCollaborators.length > 0) {
                                    const collabPoints = points * 0.5;
                                    songCollaborators.forEach(collab => {
                                        allTimeArtistPoints.set(collab, (allTimeArtistPoints.get(collab) || 0) + collabPoints);
                                    });
                                }

                                // Track song appearances and points
                                allTimeMostTop10Appearances.set(songKey, {
                                    count: (allTimeMostTop10Appearances.get(songKey)?.count || 0) + 1,
                                    songArtist: songArtistFullString
                                });
                                allTimeSongPoints.set(songKey, (allTimeSongPoints.get(songKey) || 0) + points);

                                // Calculate Release Date and aggregate points based on it
                                let releaseDate = songReleaseDates.get(songKey);
                                if (!releaseDate) { // Calculate only once per song
                                    releaseDate = calculateReleaseDate(chartDate, daysSinceRelease);
                                    if (releaseDate) {
                                        songReleaseDates.set(songKey, releaseDate); // Store it
                                    }
                                }

                                if (releaseDate) {
                                    const releaseYearMonth = `${releaseDate.getFullYear()}-${(releaseDate.getMonth() + 1).toString().padStart(2, '0')}`;
                                    const releaseYear = releaseDate.getFullYear().toString();

                                    releaseMonthPoints.set(releaseYearMonth, (releaseMonthPoints.get(releaseYearMonth) || 0) + points);
                                    releaseYearPoints.set(releaseYear, (releaseYearPoints.get(releaseYear) || 0) + points);
                                }
                            }
                        });
                    }
                }

                // --- Display Historical Highlights ---

                // Longest Reigning #1
                if (allTimeNumberOneCounts.size > 0) {
                    let longestReignSong = null;
                    let maxDaysAtOne = 0;
                    for (const [key, value] of allTimeNumberOneCounts.entries()) {
                        if (value.count > maxDaysAtOne) {
                            maxDaysAtOne = value.count;
                            longestReignSong = value.songArtist;
                        }
                    }
                    if (longestReignSong) {
                        const parsed = parseSongArtistForDisplay(longestReignSong);
                        historicalHighlightsList += `<li><strong>Longest Reigning #1:</strong> '${parsed.song}' by ${parsed.artist} has spent a total of <span class='highlight'>${maxDaysAtOne}</span> days at the #1 spot across all recorded history.</li>`;
                        noHistoricalHighlights = false;
                    }
                }

                // Song with most Top 10 appearances
                if (allTimeMostTop10Appearances.size > 0) {
                    let mostAppearancesSong = null;
                    let maxAppearances = 0;
                    for (const [key, value] of allTimeMostTop10Appearances.entries()) {
                        if (value.count > maxAppearances) {
                            maxAppearances = value.count;
                            mostAppearancesSong = value.songArtist;
                        }
                    }
                    if (mostAppearancesSong) {
                        const parsed = parseSongArtistForDisplay(mostAppearancesSong);
                        historicalHighlightsList += `<li><strong>Most Top 10 Appearances:</strong> '${parsed.song}' by ${parsed.artist} has appeared in the Top 10 on <span class='highlight'>${maxAppearances}</span> different days.</li>`;
                        noHistoricalHighlights = false;
                    }
                }

                // Top Artist by Cumulative Score
                if (allTimeArtistPoints.size > 0) {
                    let topArtistByPoints = null;
                    let maxPoints = 0;
                    for (const [artist, points] of allTimeArtistPoints.entries()) {
                        if (points > maxPoints) {
                            maxPoints = points;
                            topArtistByPoints = artist;
                        }
                    }
                    if (topArtistByPoints) {
                        historicalHighlightsList += `<li><strong>Top Artist by Cumulative Score:</strong> <strong>${topArtistByPoints}</strong> has accumulated the most points with a total of <span class='highlight'>${formatNumber(maxPoints)}</span> points across all their Top 10 appearances.</li>`;
                        noHistoricalHighlights = false;
                    }
                }

                // Best Month of Current Year (based on release date)
                const currentYear = new Date(latestDate).getFullYear().toString();
                // Filter and sort for the current year, based on releaseMonthPoints
                const currentYearReleaseMonths = Array.from(releaseMonthPoints.entries())
                    .filter(([monthYear, _]) => monthYear.startsWith(currentYear))
                    .sort((a, b) => b[1] - a[1]); 

                if (currentYearReleaseMonths.length > 0) {
                    const [bestMonthKey, bestMonthPoints] = currentYearReleaseMonths[0];
                    const monthName = new Date(bestMonthKey).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    historicalHighlightsList += `<li><strong>Best Release Month (Current Year - ${currentYear}):</strong> Songs released in <strong>${monthName}</strong> of this year have collectively earned the most points, with <span class='highlight'>${formatNumber(bestMonthPoints)}</span> total points.</li>`;
                    noHistoricalHighlights = false;
                }

                // Best Month of All Time (based on release date)
                if (releaseMonthPoints.size > 0) {
                    let bestMonthAllTimeKey = null;
                    let maxMonthPoints = 0;
                    for (const [monthYear, points] of releaseMonthPoints.entries()) {
                        if (points > maxMonthPoints) {
                            maxMonthPoints = points;
                            bestMonthAllTimeKey = monthYear;
                        }
                    }
                    if (bestMonthAllTimeKey) {
                        const monthName = new Date(bestMonthAllTimeKey).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                        historicalHighlightsList += `<li><strong>Best Release Month (All Time):</strong> Songs released in <strong>${monthName}</strong> have accumulated the highest cumulative Top 10 score of <span class='highlight'>${formatNumber(maxMonthPoints)}</span> points.</li>`;
                        noHistoricalHighlights = false;
                    }
                }

                // Best Year of All Time (based on release date)
                if (releaseYearPoints.size > 0) {
                    let bestYearAllTime = null;
                    let maxYearPoints = 0;
                    for (const [year, points] of releaseYearPoints.entries()) {
                        if (points > maxYearPoints) {
                            maxYearPoints = points;
                            bestYearAllTime = year;
                        }
                    }
                    if (bestYearAllTime) {
                        historicalHighlightsList += `<li><strong>Best Release Year (All Time):</strong> Songs released in <strong>${bestYearAllTime}</strong> have collectively accumulated the most Top 10 points with a grand total of <span class='highlight'>${formatNumber(maxYearPoints)}</span> points.</li>`;
                        noHistoricalHighlights = false;
                    }
                }


                if (noHistoricalHighlights) {
                    historicalHighlightsList += "<li>No specific historical records to highlight or insufficient data for some calculations.</li>";
                }
                historicalHighlightsList += "</ul>";
                htmlOutput += historicalHighlightsList;


                resumenContainer.innerHTML = htmlOutput;

            })
            .catch(error => {
                console.error('Error loading or processing data:', error);
                resumenContainer.innerHTML = `<p>An error occurred while loading insights. Please check the console for more details. Ensure that <code>spotify_historial.json</code> is accessible and correctly formatted.</p>`;
                fechaHeader.textContent = "Error";
            });
    });
    </script>
</body>
</html>
