<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Global Top 10 Insights</title>
    <style>
        /* Basic styles - assuming Poppins font */
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 2rem;
            background-color: #121212;
            color: #e0e0e0;
            line-height: 1.6;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #181818;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }
        h1, h2 {
            color: #1DB954; /* Spotify Green */
            border-bottom: 1px solid #282828;
            padding-bottom: 0.5rem;
            margin-top: 1.5rem;
        }
        h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
        }
        h2 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
        }
        p, li {
            font-size: 1rem;
            color: #b3b3b3;
        }
        strong {
            color: #e0e0e0;
            font-weight: 600;
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        li {
            background-color: #282828;
            margin-bottom: 0.75rem;
            padding: 1rem;
            border-radius: 5px;
            border-left: 3px solid #1DB954;
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Space between items like icon and text */
        }
        .highlight {
            color: #1DB954;
            font-weight: bold;
        }
        .negative-highlight {
            color: #ff4d4f; /* Red for negative changes */
            font-weight: bold;
        }
        .date-header {
            text-align: center;
            font-size: 1.2rem;
            color: #b3b3b3;
            margin-bottom: 2rem;
        }
        .back-button {
            display: inline-block;
            margin-bottom: 2rem;
            padding: 10px 20px;
            background-color: #1DB954;
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: #1AA34A;
        }
        .movement-icon {
            font-size: 1.2em; /* Adjust size as needed */
            vertical-align: middle;
        }
        .movement-icon.up { color: #1DB954; } /* Green for up */
        .movement-icon.down { color: #ff4d4f; } /* Red for down */
        .movement-icon.neutral { color: #b3b3b3; } /* Grey for no change */

        /* Loading spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #1DB954;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-button">← Back to Main Dashboard</a>

        <h1>Spotify Global Top 10 Insights</h1>
        <p id="fecha-actualizacion" class="date-header"><span class="spinner"></span> Loading data...</p>

        <div id="resumen-novedades">
            </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const resumenContainer = document.getElementById('resumen-novedades');
        const fechaHeader = document.getElementById('fecha-actualizacion');

        // --- Helper Functions ---
        function parseSongArtistForDisplay(songArtistString) {
            if (!songArtistString) return { artist: 'Unknown', song: 'Unknown' };
            const parts = songArtistString.split(' - ');
            if (parts.length > 1) {
                const artist = parts.shift().trim();
                const song = parts.join(' - ').trim();
                return { artist, song };
            }
            return { artist: 'Unknown Artist', song: songArtistString.trim() };
        }

        function formatNumber(num) {
            if (typeof num === 'string' && num.includes(',')) num = num.replace(/,/g, ''); // Remove commas if string
            const number = parseInt(num, 10);
            return isNaN(number) ? '-' : number.toLocaleString('en-US'); // Use en-US for commas
        }

        function getPositionChangeText(currentPos, prevPos) {
            let icon = '';
            let text = '';
            let className = '';

            if (prevPos === null || prevPos === undefined) {
                icon = '✨'; // Star or new entry icon
                text = "(New Entry)";
                className = 'highlight';
            } else {
                const change = prevPos - currentPos;
                if (change > 0) {
                    icon = '⬆️'; // Up arrow
                    text = `(Up <span class='highlight'>${change}</span> ${change === 1 ? 'position' : 'positions'})`;
                    className = 'up';
                } else if (change < 0) {
                    icon = '⬇️'; // Down arrow
                    text = `(Down <span class='negative-highlight'>${Math.abs(change)}</span> ${Math.abs(change) === 1 ? 'position' : 'positions'})`;
                    className = 'down';
                } else {
                    icon = '➡️'; // Right arrow for no change
                    text = "(Maintains position)";
                    className = 'neutral';
                }
            }
            return `<span class="movement-icon ${className}">${icon}</span> ${text}`;
        }

        // Function to calculate points based on position (similar to Eurovision scoring)
        function calculatePoints(position) {
            const pointsMap = {
                1: 12,
                2: 10,
                3: 8,
                4: 7,
                5: 6,
                6: 5,
                7: 4,
                8: 3,
                9: 2,
                10: 1
            };
            return pointsMap[position] || 0;
        }

        fetch('spotify_historial.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                const dates = Object.keys(data).sort((a, b) => new Date(b) - new Date(a));
                
                if (dates.length === 0) {
                    resumenContainer.innerHTML = "<p>No data available in the history.</p>";
                    fechaHeader.textContent = "No data";
                    return;
                }

                const latestDate = dates[0];
                const previousDate = dates.length > 1 ? dates[1] : null;

                const latestTop10 = data[latestDate]?.top_10 || [];
                const previousTop10Data = previousDate ? (data[previousDate]?.top_10 || []) : [];

                // Map previous top 10 for easy lookup
                const previousSongsMap = new Map();
                previousTop10Data.forEach(song => {
                    const key = (song["Song / Artist"] || song["Canción / Artista"] || "").toLowerCase();
                    if (key) {
                        previousSongsMap.set(key, song);
                    }
                });
                
                // Format the date for display
                const displayDate = new Date(latestDate).toLocaleDateString('en-US', {
                    year: 'numeric', month: 'long', day: 'numeric'
                });
                fechaHeader.innerHTML = `Analysis for ${displayDate}`; // Remove spinner

                let htmlOutput = "";

                // 1. Daily Overview
                htmlOutput += `<h2>Daily Overview</h2>`;
                if (latestTop10.length > 0) {
                    const { song: songN1, artist: artistN1 } = parseSongArtistForDisplay(latestTop10[0]["Song / Artist"] || latestTop10[0]["Canción / Artista"]);
                    htmlOutput += `<p>Today, <strong>${songN1}</strong> by <strong>${artistN1}</strong> leads the Global Top 10.</p>`;
                } else {
                    htmlOutput += `<p>No Top 10 data available for today.</p>`;
                }


                // 2. New Entries and Movements
                const newEntries = [];
                const movements = []; // For climbs, drops, maintains

                latestTop10.forEach(currentSong => {
                    const songKey = (currentSong["Song / Artist"] || currentSong["Canción / Artista"] || "").toLowerCase();
                    const parsedCurrent = parseSongArtistForDisplay(currentSong["Song / Artist"] || currentSong["Canción / Artista"]);
                    const currentPos = parseInt(currentSong.Posición || currentSong.Position, 10);
                    const currentStreams = formatNumber(currentSong.Streams);

                    const prevSongData = previousSongsMap.get(songKey);
                    const prevPos = prevSongData ? parseInt(prevSongData.Posición || prevSongData.Position, 10) : null;
                    
                    const changeText = getPositionChangeText(currentPos, prevPos);

                    let listItem = `<li>${changeText} <strong>#${currentPos} ${parsedCurrent.song}</strong> by ${parsedCurrent.artist}. Streams: ${currentStreams}.`;
                    if (currentSong["Stream Diff"]) {
                        const diff = parseInt(String(currentSong["Stream Diff"]).replace(/,/g, ''), 10); // Clean and convert
                        if (!isNaN(diff)) {
                             listItem += ` Stream difference: <span class="${diff >= 0 ? 'highlight' : 'negative-highlight'}">${formatNumber(diff)}</span>.`;
                        }
                    }
                    listItem += `</li>`;


                    if (prevPos === null) {
                        newEntries.push(listItem);
                    } else {
                        movements.push({pos: currentPos, item: listItem});
                    }
                });
                
                // Sort 'movements' by current position to display them in order
                movements.sort((a,b) => a.pos - b.pos);


                if (newEntries.length > 0) {
                    htmlOutput += `<h2>New Entries in the Top 10</h2><ul>${newEntries.join('')}</ul>`;
                } else {
                    htmlOutput += `<h2>New Entries in the Top 10</h2><p>No new entries in the Top 10 today.</p>`;
                }

                htmlOutput += `<h2>Current Positions & Movements</h2>`;
                if (movements.length > 0) {
                    htmlOutput += `<ul>${movements.map(m => m.item).join('')}</ul>`;
                } else if (newEntries.length === 0) { // If no movements and no new entries (rare)
                    htmlOutput += `<p>The Top 10 remains identical to the previous day or insufficient data for comparison.</p>`;
                } else { // If only new entries but no other movements (because the rest left)
                    htmlOutput += `<p>All songs not listed as new entries have left the Top 10.</p>`;
                }


                // 3. Daily Highlights & Key Data
                htmlOutput += `<h2>Daily Highlights</h2>`;
                let dailyHighlightsList = "<ul>";
                let noDailyHighlights = true;

                // Song with most streams
                if (latestTop10.length > 0) {
                    let maxStreams = -1;
                    let songMaxStreams = null;
                    latestTop10.forEach(s => {
                        const streams = parseInt(String(s.Streams).replace(/,/g, ''), 10);
                        if (!isNaN(streams) && streams > maxStreams) {
                            maxStreams = streams;
                            songMaxStreams = s;
                        }
                    });
                    if (songMaxStreams) {
                        const parsed = parseSongArtistForDisplay(songMaxStreams["Song / Artist"] || songMaxStreams["Canción / Artista"]);
                        dailyHighlightsList += `<li><strong>Stream Leader:</strong> '${parsed.song}' by ${parsed.artist} has the most streams today, accumulating <strong>${formatNumber(maxStreams)}</strong> plays.</li>`;
                        noDailyHighlights = false;
                    }
                }
                
                // Song with largest stream increase (Stream Diff)
                if (latestTop10.length > 0 && previousDate) { // Only if there's a previous day to compare
                    let maxStreamDiff = -Infinity; // Start low to find the highest positive
                    let songMaxStreamDiff = null;
                    latestTop10.forEach(s => {
                        if (s["Stream Diff"]) {
                            const diff = parseInt(String(s["Stream Diff"]).replace(/,/g, ''), 10);
                            if (!isNaN(diff) && diff > maxStreamDiff) {
                                maxStreamDiff = diff;
                                songMaxStreamDiff = s;
                            }
                        }
                    });

                    if (songMaxStreamDiff && maxStreamDiff > 0) { // Only show if there's a positive increase
                        const parsed = parseSongArtistForDisplay(songMaxStreamDiff["Song / Artist"] || songMaxStreamDiff["Canción / Artista"]);
                        dailyHighlightsList += `<li><strong>Biggest Stream Growth:</strong> '${parsed.song}' by ${parsed.artist} saw the largest increase in streams from the previous day, with <strong>+${formatNumber(maxStreamDiff)}</strong> streams.</li>`;
                        noDailyHighlights = false;
                    }
                }

                // Biggest Climber
                let biggestClimber = null;
                let maxPositionGain = 0; 
                latestTop10.forEach(currentSong => {
                    const songKey = (currentSong["Song / Artist"] || currentSong["Canción / Artista"] || "").toLowerCase();
                    const currentPos = parseInt(currentSong.Posición || currentSong.Position, 10);
                    const prevSongData = previousSongsMap.get(songKey);
                    const prevPos = prevSongData ? parseInt(prevSongData.Posición || prevSongData.Position, 10) : null;

                    if (prevPos !== null) { 
                        const positionGain = prevPos - currentPos;
                        if (positionGain > maxPositionGain) {
                            maxPositionGain = positionGain;
                            biggestClimber = currentSong;
                        }
                    }
                });

                if (biggestClimber && maxPositionGain > 0) {
                    const parsed = parseSongArtistForDisplay(biggestClimber["Song / Artist"] || biggestClimber["Canción / Artista"]);
                    dailyHighlightsList += `<li><strong>Top Climber:</strong> '${parsed.song}' by ${parsed.artist} made the biggest climb today, rising <span class='highlight'>${maxPositionGain}</span> positions to reach <strong>#${parseInt(biggestClimber.Posición || biggestClimber.Position, 10)}</strong>.</li>`;
                    noDailyHighlights = false;
                }

                // Biggest Dropper
                let biggestDropper = null;
                let maxPositionDrop = 0; 
                latestTop10.forEach(currentSong => {
                    const songKey = (currentSong["Song / Artist"] || currentSong["Canción / Artista"] || "").toLowerCase();
                    const currentPos = parseInt(currentSong.Posición || currentSong.Position, 10);
                    const prevSongData = previousSongsMap.get(songKey);
                    const prevPos = prevSongData ? parseInt(prevSongData.Posición || prevSongData.Position, 10) : null;

                    if (prevPos !== null) {
                        const positionDrop = currentPos - prevPos; 
                        if (positionDrop > maxPositionDrop) {
                            maxPositionDrop = positionDrop;
                            biggestDropper = currentSong;
                        }
                    }
                });

                if (biggestDropper && maxPositionDrop > 0) { 
                    const parsed = parseSongArtistForDisplay(biggestDropper["Song / Artist"] || biggestDropper["Canción / Artista"]);
                    dailyHighlightsList += `<li><strong>Top Dropper:</strong> '${parsed.song}' by ${parsed.artist} experienced the biggest drop, falling <span class='negative-highlight'>${maxPositionDrop}</span> positions to <strong>#${parseInt(biggestDropper.Posición || biggestDropper.Position, 10)}</strong>.</li>`;
                    noDailyHighlights = false;
                }


                // If #1 maintained and was in previous day
                if (latestTop10.length > 0 && previousTop10Data.length > 0) {
                    const currentN1Key = (latestTop10[0]["Song / Artist"] || latestTop10[0]["Canción / Artista"] || "").toLowerCase();
                    const prevN1Key = (previousTop10Data[0]["Song / Artist"] || previousTop10Data[0]["Canción / Artista"] || "").toLowerCase();
                    if (currentN1Key === prevN1Key && parseInt(latestTop10[0].Posición || latestTop10[0].Position, 10) === 1) {
                           const parsed = parseSongArtistForDisplay(latestTop10[0]["Song / Artist"] || latestTop10[0]["Canción / Artista"]);
                           dailyHighlightsList += `<li><strong>Holding the Top Spot:</strong> '${parsed.song}' by ${parsed.artist} remains strong at <strong>#1</strong>.</li>`;
                           noDailyHighlights = false;
                    }
                }


                if (noDailyHighlights) {
                    dailyHighlightsList += "<li>No specific daily highlights to feature today or insufficient data for some calculations.</li>";
                }
                dailyHighlightsList += "</ul>";
                htmlOutput += dailyHighlightsList;

                // 4. All-Time Records & Historical Insights (Needs to iterate through ALL data)
                htmlOutput += `<h2>All-Time Records & Historical Insights</h2>`;
                let historicalHighlightsList = "<ul>";
                let noHistoricalHighlights = true;

                // Calculate all-time #1 song
                let allTimeNumberOne = new Map(); // songKey -> {count: num_days_at_1, songArtist: "..."}
                let allTimeMostTop10Appearances = new Map(); // songKey -> {count: num_days_in_top10, songArtist: "..."}
                let allTimeArtistPoints = new Map(); // artistName -> total_points

                for (const date of dates) {
                    const dailyTop10 = data[date]?.top_10 || [];
                    if (dailyTop10.length > 0) {
                        const topSong = dailyTop10[0];
                        const topSongKey = (topSong["Song / Artist"] || topSong["Canción / Artista"] || "").toLowerCase();
                        if (topSongKey) {
                            allTimeNumberOne.set(topSongKey, {
                                count: (allTimeNumberOne.get(topSongKey)?.count || 0) + 1,
                                songArtist: topSong["Song / Artist"] || topSong["Canción / Artista"]
                            });
                        }

                        dailyTop10.forEach(song => {
                            const songKey = (song["Song / Artist"] || song["Canción / Artista"] || "").toLowerCase();
                            if (songKey) {
                                allTimeMostTop10Appearances.set(songKey, {
                                    count: (allTimeMostTop10Appearances.get(songKey)?.count || 0) + 1,
                                    songArtist: song["Song / Artist"] || song["Canción / Artista"]
                                });
                            }

                            // Calculate points for artists
                            const parsed = parseSongArtistForDisplay(song["Song / Artist"] || song["Canción / Artista"]);
                            const position = parseInt(song.Posición || song.Position, 10);
                            if (!isNaN(position)) {
                                const points = calculatePoints(position);
                                allTimeArtistPoints.set(parsed.artist, (allTimeArtistPoints.get(parsed.artist) || 0) + points);
                            }
                        });
                    }
                }

                // Find the longest reigning #1
                if (allTimeNumberOne.size > 0) {
                    let longestReignSong = null;
                    let maxDaysAtOne = 0;
                    for (const [key, value] of allTimeNumberOne.entries()) {
                        if (value.count > maxDaysAtOne) {
                            maxDaysAtOne = value.count;
                            longestReignSong = value.songArtist;
                        }
                    }
                    if (longestReignSong) {
                        const parsed = parseSongArtistForDisplay(longestReignSong);
                        historicalHighlightsList += `<li><strong>Longest Reigning #1:</strong> '${parsed.song}' by ${parsed.artist} has spent a total of <span class='highlight'>${maxDaysAtOne}</span> days at the #1 spot since 2017.</li>`;
                        noHistoricalHighlights = false;
                    }
                }

                // Find the song with most Top 10 appearances
                if (allTimeMostTop10Appearances.size > 0) {
                    let mostAppearancesSong = null;
                    let maxAppearances = 0;
                    for (const [key, value] of allTimeMostTop10Appearances.entries()) {
                        if (value.count > maxAppearances) {
                            maxAppearances = value.count;
                            mostAppearancesSong = value.songArtist;
                        }
                    }
                    if (mostAppearancesSong) {
                        const parsed = parseSongArtistForDisplay(mostAppearancesSong);
                        historicalHighlightsList += `<li><strong>Most Top 10 Appearances:</strong> '${parsed.song}' by ${parsed.artist} has appeared in the Top 10 on <span class='highlight'>${maxAppearances}</span> different days.</li>`;
                        noHistoricalHighlights = false;
                    }
                }

                // Find artist with most cumulative points
                if (allTimeArtistPoints.size > 0) {
                    let topArtistByPoints = null;
                    let maxPoints = 0;
                    for (const [artist, points] of allTimeArtistPoints.entries()) {
                        if (points > maxPoints) {
                            maxPoints = points;
                            topArtistByPoints = artist;
                        }
                    }
                    if (topArtistByPoints) {
                        historicalHighlightsList += `<li><strong>Top Artist by Cumulative Score:</strong> <strong>${topArtistByPoints}</strong> has accumulated the most points (based on Top 10 positions) with a total of <span class='highlight'>${formatNumber(maxPoints)}</span> points across all their songs.</li>`;
                        noHistoricalHighlights = false;
                    }
                }


                if (noHistoricalHighlights) {
                    historicalHighlightsList += "<li>No specific historical records to highlight or insufficient data for some calculations.</li>";
                }
                historicalHighlightsList += "</ul>";
                htmlOutput += historicalHighlightsList;


                resumenContainer.innerHTML = htmlOutput;

            })
            .catch(error => {
                console.error('Error loading or processing data:', error);
                resumenContainer.innerHTML = `<p>An error occurred while loading insights. Please check the console for more details. Ensure that <code>spotify_historial.json</code> is accessible and correctly formatted.</p>`;
                fechaHeader.textContent = "Error";
            });
    });
    </script>
</body>
</html>
